bool f_rayBvhIntersection(in Ray ray, in Bvh box, inout float ray_length) {
	vec3 f = (box.p_min - ray.origin) * ray.direction;
	vec3 n = (box.p_max - ray.origin) * ray.direction;

	vec3 tmax = max(f, n);
	vec3 tmin = min(f, n);

	float t1 = min(tmax.x, min(tmax.y, tmax.z));
	float t0 = max(tmin.x, max(tmin.y, tmin.z));

	if (t1 >= t0) {
		if (t0 > 0.0f) {
			ray_length = t0;
		}
		else {
			ray_length = t1;
		}
		return true;
	}
	return false;
}

bool f_raySphereIntersection(in Ray ray, in vec3 sphere, out float t) {
	vec3 CO = ray.origin - sphere;
	float a = dot(ray.direction, ray.direction);
	float b = 2.0*dot(ray.direction, CO);
	float c = dot(CO, CO) - sphere_display_radius*sphere_display_radius;
	float delta = b*b - 4.0*a*c;
	if(delta < 0.0) {
		return false;
	}
	t = (-b-sqrt(delta)) / (2.0*a);
	return true;
}

bool f_EarthIntersection(in Ray ray, out float t, out vec2 uv) {
	float a = dot(ray.direction, ray.direction);
	float b = 2.0*dot(ray.direction, ray.origin);
	float c = dot(ray.origin, ray.origin) - 40.589641f;
	float delta = b*b - 4.0*a*c;
	if(delta < 0.0) {
		return false;
	}
	t = (-b-sqrt(delta)) / (2.0 * a);

	vec3 intersectionPoint = ray.origin + t * ray.direction;
	vec3 normal = normalize(intersectionPoint );
	
	float theta = acos(normal.y);
	float phi = atan(normal.z, normal.x);
	
	uv.x = 1.0 - ((phi + 3.14159265358979323846) / (2.0 * 3.14159265358979323846));
	uv.y = (theta) / 3.14159265358979323846;
	return true;
}

uvec2 f_visitBvh(in Ray ray, in Bvh node, inout uint bvh_depth) {
	float t_dist_a = MAX_DIST;
	float t_dist_b = MAX_DIST;
	Bvh node_a;
	Bvh node_b;
	Bvh current_node = node;
	uint depth = 0;

	while (current_node.particle_count == 0) {
		depth++;
		bvh_depth++;
		t_dist_a = MAX_DIST;
		t_dist_b = MAX_DIST;
		node_a = bvh_nodes[current_node.pointer_a];
		node_b = bvh_nodes[current_node.pointer_b];
		f_rayBvhIntersection(ray, node_a, t_dist_a);
		f_rayBvhIntersection(ray, node_b, t_dist_b);
		
		if (t_dist_a < t_dist_b && t_dist_a < MAX_DIST) {
			current_node = node_a;
		}
		else {
			current_node = node_b;
		}
		if (depth > 64) {
			break;
		}
	}
	return uvec2(current_node.pointer_particle, current_node.particle_count);
}