bool f_rayBvhIntersection(in Ray ray, in Bvh box, inout float ray_length) {
	vec3 f = (box.p_min - ray.origin) * ray.direction;
	vec3 n = (box.p_max - ray.origin) * ray.direction;

	vec3 tmax = max(f, n);
	vec3 tmin = min(f, n);

	float t1 = min(tmax.x, min(tmax.y, tmax.z));
	float t0 = max(tmin.x, max(tmin.y, tmin.z));

	if (t1 >= t0) {
		if (t0 > 0.0f) {
			ray_length = t0;
		}
		else {
			ray_length = t1;
		}
		return true;
	}
	return false;
}

bool f_rayBvhIntersection(in Ray ray, in Bvh box) {
	vec3 f = (box.p_min - ray.origin) * ray.direction;
	vec3 n = (box.p_max - ray.origin) * ray.direction;

	vec3 tmax = max(f, n);
	vec3 tmin = min(f, n);

	float t1 = min(tmax.x, min(tmax.y, tmax.z));
	float t0 = max(tmin.x, max(tmin.y, tmin.z));

	if (t1 >= t0) {
		return true;
	}
	return false;
}

bool f_raySphereIntersection(in Ray ray, in vec3 sphere, out float t) {
	vec3 CO = ray.origin - sphere;
	float a = dot(ray.direction, ray.direction);
	float b = 2.0*dot(ray.direction, CO);
	float c = dot(CO, CO) - sphere_display_radius*sphere_display_radius;
	float delta = b*b - 4.0*a*c;
	if(delta < 0.0) {
		return false;
	}
	t = (-b-sqrt(delta)) / (2.0*a);
	return true;
}

bool f_EarthIntersection(in Ray ray, out float t, out vec2 uv) {
	float a = dot(ray.direction, ray.direction);
	float b = 2.0*dot(ray.direction, ray.origin);
	float c = dot(ray.origin, ray.origin) - 40.589641f;
	float delta = b*b - 4.0*a*c;
	if(delta < 0.0) {
		return false;
	}
	t = (-b-sqrt(delta)) / (2.0 * a);

	vec3 intersectionPoint = ray.origin + t * ray.direction;
	vec3 normal = normalize(intersectionPoint );
	
	float theta = acos(normal.y);
	float phi = atan(normal.z, normal.x);
	
	uv.x = 1.0 - ((phi + 3.14159265358979323846) / (2.0 * 3.14159265358979323846));
	uv.y = (theta) / 3.14159265358979323846;
	return true;
}

int f_visitBvh(in Ray ray, in Bvh node, inout float result_raylength) {
	Ray bvh_ray = Ray(ray.origin, normalize(1.0 / ray.direction));
	
	float t_length = MAX_DIST;
	float t_dist = MAX_DIST;

	int closest_particle = -1;
	int stack[64];
	int stackSize = 0;
	stack[stackSize++] = 0;

	while (stackSize > 0) {
		--stackSize;
		bvh_depth++;

		int currentNode = stack[stackSize];
		Bvh node = bvh_nodes[currentNode];

		if (!f_rayBvhIntersection(bvh_ray, node)) {
			continue;
		}
		if (node.particle_count > 0) {
			for (uint i = node.particle_pointer; i < node.particle_count; ++i) {
				if (f_raySphereIntersection(ray, point_cloud[i].position.xyz, t_dist)) {
					if (t_dist < t_length) {
						t_length = t_dist;
						result_raylength = t_dist;
						closest_particle = int(i);
					}
				}
			}
		} else {
			for (int i = 0; i < 8; ++i) {
				if (i < 4) {
					int childIndex = node.pointers_a[i];
					if (childIndex >= 0) {
						stack[stackSize++] = childIndex;
					}
				}
				else {
					int childIndex = node.pointers_b[i - 4];
					if (childIndex >= 0) {
						stack[stackSize++] = childIndex;
					}
				}
			}
		}
	}
	return closest_particle;
}