float f_mapFloat(float from_min, float from_max, float to_min, float to_max, float value) {
	return (to_min + ((to_max - to_min) / (from_max - from_min)) * (value - from_min));
}

vec3 hsv2rgb(vec3 c) {
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec4 floatToColor(float f) {
	vec3 color = hsv2rgb(vec3(f, 1.0, 1.0));
	return vec4(color, 1.0);
}

vec4 blendColors(vec4 bottomLayer, vec4 topLayer) {
	vec3 topColor = topLayer.rgb;
	vec3 bottomColor = bottomLayer.rgb;
	float topAlpha = topLayer.a;
	float bottomAlpha = bottomLayer.a;
	float outAlpha = topAlpha + bottomAlpha * (1.0 - topAlpha);
	vec3 outColor = (topColor * topAlpha + bottomColor * bottomAlpha * (1.0 - topAlpha)) / outAlpha;
	return vec4(outColor, outAlpha);
}

vec3 velocityToColor(vec3 velocity) {
	vec3 color;
	float speed = length(velocity);
	float normalizedSpeed = clamp(f_mapFloat(0.0, 1.0, 0.0, 1.0, speed), 0.0, 1.0);

	if (normalizedSpeed <= 0.5) {
		float t = normalizedSpeed * 2.0;
		color = mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), t);
	}
	else {
		float t = (normalizedSpeed - 0.5) * 2.0;
		color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), t);
	}
	return color;
}

vec3 f_temperatureToColor(float temp) {
	vec3 color;
	float t = clamp(f_mapFloat(0.0, 1.0, 1.0, 0.0, temp), 0.0, 1.0);

	if (t < 0.25) {
		// Interpolate from Red to Yellow
		float f = t / 0.25;
		color = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), f);  // Red to Yellow
	} else if (t < 0.5) {
		// Interpolate from Yellow to Green
		float f = (t - 0.25) / 0.25;
		color = mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), f);  // Yellow to Green
	} else if (t < 0.75) {
		// Interpolate from Green to Blue
		float f = (t - 0.5) / 0.25;
		color = mix(vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), f);  // Green to Blue
	} else {
		// Interpolate from Blue to Purple
		float f = (t - 0.75) / 0.25;
		color = mix(vec3(0.0, 0.0, 1.0), vec3(0.5, 0.0, 0.5), f);  // Blue to Purple
	}
	return color;
}

vec3 f_particleColor(in Particle particle, in float dist) {
	float distance_factor = clamp(f_mapFloat(39.0, 32.0, 0.0, 1.0, dist), 0, 1);
	switch (render_particle_color_mode) {
		case 0: return f_temperatureToColor(f_mapFloat(-25.0, 45.0, 0.0, 1.0, particle.temperature));
	}
	return vec3(1,0,1);
}

vec4 f_earthColor(in vec2 uv) {
	vec4 color = sampleTextureRgba8u(textures[render_planet_texture], uv);
	switch (render_planet_texture) {
		case 0: return color;
		case 1: {
			float mappedValue1 = f_mapFloat(-25.0, 45.0, 0.0, 1.0, -2.0);
			float mappedValue2 = f_mapFloat(-25.0, 45.0, 0.0, 1.0, 35.0);
			return vec4(f_temperatureToColor(f_mapFloat(0.0, 1.0, mappedValue1, mappedValue2, color.x)), 1.0);
		}
		case 2: {
			return vec4(f_temperatureToColor(color.x), 1.0);
		}
	}
	return vec4(1,0,1, 1);
}