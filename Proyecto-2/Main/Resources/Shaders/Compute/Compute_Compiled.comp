//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
#version 460
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
struct Particle {
	vec3  position;
	float temperature;
};

struct Texture {
	uint start;
	uint width;
	uint height;
	uint format;
};

struct Bvh {
	vec3 p_min;
	uint particle_start;
	vec3 p_max;
	uint particle_end;
	ivec4 pointers_a;
	ivec4 pointers_b;
};
// INTERNAL ---------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------

struct Ray {
	vec3  origin;
	vec3  direction;
};
// DEFINITIONS ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
#define TWO_PI   6.28318530718
#define PI       3.14159265359
#define HALF_PI  1.57079632679
#define INV_PI   0.31830988618
#define DEG_RAD  0.01745329252
#define RAD_DEG  0.01745329252

#define MAX_DIST 1000.0
#define EPSILON  0.00001

#define MAX_UINT 4294967295
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(rgba8, binding = 0) writeonly uniform image2D raw_render_layer;

layout(std430, binding = 1) buffer ParticleBuffer {
	Particle particles[];
};

layout(std430, binding = 2) buffer BvhBuffer {
	Bvh bvh_nodes[];
};

layout(std430, binding = 3) buffer TextureBuffer {
	Texture textures[];
};

layout(std430, binding = 4) buffer TextureDataBuffer {
	uint texture_data[];
};

uniform uint  frame_count;
uniform float aspect_ratio;
uniform float current_time;
uniform uvec2 resolution;

uniform vec3 camera_pos;
uniform vec3 camera_p_uv;
uniform vec3 camera_p_u;
uniform vec3 camera_p_v;

uniform Bvh  root_bvh;

uniform float sphere_radius;
uniform float sphere_display_radius;

uniform uint  render_planet;
uniform uint  render_octree;
uniform uint  render_octree_hue;
uniform uint  render_octree_debug;
uniform int   render_octree_debug_index;

uniform uint  render_particles;
uniform int   render_particle_color_mode;

uniform int   render_planet_texture;
vec4 sampleTextureRgba8u(in Texture tex, in vec2 uv) {
	uint x = uint(uv.x * float(tex.width));
	uint y = uint(uv.y * float(tex.height));

	x = clamp(x, 0, tex.width - 1);
	y = clamp(y, 0, tex.height - 1);

	uint index = tex.start + y * tex.width + x;
	uint color = texture_data[index];

	return vec4(
		float((color >> 24) & 0xFF) / 255.0,
		float((color >> 16) & 0xFF) / 255.0,
		float((color >> 8) & 0xFF) / 255.0,
		float(color & 0xFF) / 255.0
	);
}
float f_mapFloat(float from_min, float from_max, float to_min, float to_max, float value) {
	return (to_min + ((to_max - to_min) / (from_max - from_min)) * (value - from_min));
}

vec3 hsv2rgb(vec3 c) {
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec4 floatToColor(float f) {
	vec3 color = hsv2rgb(vec3(f, 1.0, 1.0));
	return vec4(color, 1.0);
}

vec3 velocityToColor(vec3 velocity) {
	vec3 color;
	float speed = length(velocity);
	float normalizedSpeed = clamp(f_mapFloat(0.0, 1.0, 0.0, 1.0, speed), 0.0, 1.0);

	if (normalizedSpeed <= 0.5) {
		float t = normalizedSpeed * 2.0;
		color = mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), t);
	}
	else {
		float t = (normalizedSpeed - 0.5) * 2.0;
		color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), t);
	}
	return color;
}

vec3 f_temperatureToColor(float temp) {
	vec3 color;
	float t = clamp(f_mapFloat(0.0, 1.0, 1.0, 0.0, temp), 0.0, 1.0);

	if (t < 0.25) {
		// Interpolate from Red to Yellow
		float f = t / 0.25;
		color = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), f);  // Red to Yellow
	} else if (t < 0.5) {
		// Interpolate from Yellow to Green
		float f = (t - 0.25) / 0.25;
		color = mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), f);  // Yellow to Green
	} else if (t < 0.75) {
		// Interpolate from Green to Blue
		float f = (t - 0.5) / 0.25;
		color = mix(vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), f);  // Green to Blue
	} else {
		// Interpolate from Blue to Purple
		float f = (t - 0.75) / 0.25;
		color = mix(vec3(0.0, 0.0, 1.0), vec3(0.5, 0.0, 0.5), f);  // Blue to Purple
	}
	return color;
}

vec3 f_particleColor(in Particle particle, in float dist) {
	float distance_factor = clamp(f_mapFloat(39.0, 32.0, 0.0, 1.0, dist), 0, 1);
	switch (render_particle_color_mode) {
		case 0: return f_temperatureToColor(particle.temperature);
	}
	return vec3(1,0,1);
}

vec4 f_earthColor(in vec2 uv) {
	vec4 color = sampleTextureRgba8u(textures[render_planet_texture], earth_uv);
	switch (render_planet_texture) {
		case 0: return color;
		case 0: return vec4(f_temperatureToColor(length(color.xyz)), 1.0);
		case 0: return vec4(f_temperatureToColor(length(color.xyz)), 1.0);
	}
	return vec4(1,0,1, 1);
}
bool f_rayBvhIntersection(in Ray ray, in Bvh box, inout float ray_length) {
	vec3 f = (box.p_min - ray.origin) * ray.direction;
	vec3 n = (box.p_max - ray.origin) * ray.direction;

	vec3 tmax = max(f, n);
	vec3 tmin = min(f, n);

	float t1 = min(tmax.x, min(tmax.y, tmax.z));
	float t0 = max(tmin.x, max(tmin.y, tmin.z));

	if (t1 >= t0) {
		if (t0 > 0.0f) {
			ray_length = t0;
		}
		else {
			ray_length = t1;
		}
		return true;
	}
	return false;
}

bool f_rayBvhIntersection(in Ray ray, in Bvh box) {
	vec3 f = (box.p_min - ray.origin) * ray.direction;
	vec3 n = (box.p_max - ray.origin) * ray.direction;

	vec3 tmax = max(f, n);
	vec3 tmin = min(f, n);

	float t1 = min(tmax.x, min(tmax.y, tmax.z));
	float t0 = max(tmin.x, max(tmin.y, tmin.z));

	if (t1 >= t0) {
		return true;
	}
	return false;
}

bool f_raySphereIntersection(in Ray ray, in vec3 sphere, out float t) {
	vec3 CO = ray.origin - sphere;
	float a = dot(ray.direction, ray.direction);
	float b = 2.0*dot(ray.direction, CO);
	float c = dot(CO, CO) - sphere_display_radius*sphere_display_radius;
	float delta = b*b - 4.0*a*c;
	if(delta < 0.0) {
		return false;
	}
	t = (-b-sqrt(delta)) / (2.0*a);
	return true;
}

bool f_EarthIntersection(in Ray ray, out float t, out vec2 uv) {
	float a = dot(ray.direction, ray.direction);
	float b = 2.0*dot(ray.direction, ray.origin);
	float c = dot(ray.origin, ray.origin) - 40.589641f;
	float delta = b*b - 4.0*a*c;
	if(delta < 0.0) {
		return false;
	}
	t = (-b-sqrt(delta)) / (2.0 * a);

	vec3 intersectionPoint = ray.origin + t * ray.direction;
	vec3 normal = normalize(intersectionPoint );
	
	float theta = acos(normal.y);
	float phi = atan(normal.z, normal.x);
	
	uv.x = 1.0 - ((phi + 3.14159265358979323846) / (2.0 * 3.14159265358979323846));
	uv.y = (theta) / 3.14159265358979323846;
	return true;
}

int f_visitBvh(in Ray ray, inout float result_raylength) {
	Ray bvh_ray = Ray(ray.origin, normalize(1.0 / ray.direction));

	float t_length = MAX_DIST;
	float t_dist = MAX_DIST;

	int closest_particle = -1;
	int stack[32];
	int stack_index = 0;
	stack[stack_index++] = 0;


	// TODO implement closest BVH First
	while (stack_index > 0) {
		--stack_index;

		int currentNode = stack[stack_index];
		Bvh node = bvh_nodes[currentNode];

		if (!f_rayBvhIntersection(bvh_ray, node)) {
			continue;
		}
		if (node.particle_end > 0) { // Leaf
			for (uint i = node.particle_start; i < node.particle_end; ++i) {
				if (f_raySphereIntersection(ray, particles[i].position, t_dist)) {
					if (t_dist < t_length) {
						t_length = t_dist;
						result_raylength = t_dist;
						closest_particle = int(i);
					}
				}
			}
		}
		else {
			for (int i = 0; i < 8; ++i) {
				if (i < 4) {
					int childIndex = node.pointers_a[i];
					if (childIndex >= 0) {
						stack[stack_index++] = childIndex;
					}
				}
				else {
					int childIndex = node.pointers_b[i - 4];
					if (childIndex >= 0) {
						stack[stack_index++] = childIndex;
					}
				}
			}
		}
	}
	return closest_particle;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

Ray f_cameraRay(vec2 uv) {
	return Ray(camera_pos, normalize(camera_p_uv + (camera_p_u * uv.x) + (camera_p_v * uv.y) - camera_pos));
}

void main() {
	ivec2 pixel_id = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (pixel_id - 1 - vec2(resolution) / 2.0) / float(max(resolution.x, resolution.y));

	Ray ray = f_cameraRay(uv);

	vec4 color = vec4(0,0,0,1);
	uint octree_view_depth = 0;
	vec4 octree_color = vec4(1);
	float bvh_t_length = MAX_DIST;
	Ray bvh_ray = Ray(ray.origin, 1.0 / ray.direction);

	if (render_particles == 1) {
		float t_length = MAX_DIST;
		float t_dist = MAX_DIST;
		vec2 earth_uv = vec2(0.5);
		if (render_planet == 1) {
			if (f_EarthIntersection(ray, t_dist, earth_uv)) {
				if (t_dist < t_length && t_dist > EPSILON) {
					t_length = t_dist;
					color = f_earthColor(earth_uv);
				}
			}
		}
		int closest_particle_index = f_visitBvh(ray, t_dist);
		if (closest_particle_index != -1) {
			if (t_dist < t_length && t_dist > EPSILON) {
				color = vec4(f_particleColor(particles[closest_particle_index], t_dist), 1.0);
			}
		}
	}
	else if (render_planet == 1) {
		if (f_rayBvhIntersection(bvh_ray, root_bvh)) {
			float earth_dist = MAX_DIST;
			vec2 earth_uv = vec2(0.5);
			if (f_EarthIntersection(ray, earth_dist, earth_uv)) {
				color = f_earthColor(earth_uv);
			}
		}
	}

	float octree_alpha = 1.0;
	if (render_octree == 1) {
		if (render_octree_debug == 1) {
			if (f_rayBvhIntersection(bvh_ray, bvh_nodes[render_octree_debug_index])) {
				octree_alpha = 0.5f;
				if (render_octree_hue == 1) {
					octree_color = floatToColor(float(render_octree_debug_index) / float(bvh_nodes.length()));
				}
			}
		}
		else {
			for (int i = 0; i < bvh_nodes.length(); i++) {
				Bvh node = bvh_nodes[i];
				node.p_min += 0.1;
				node.p_max -= 0.1;
				if (f_rayBvhIntersection(bvh_ray, node)) {
					octree_view_depth++;
					if (render_octree_hue == 1) {
						octree_color = floatToColor(float(i) / float(bvh_nodes.length()));
					}
				}
			}
		}
	}
	for (int i = 0; i < octree_view_depth; i++) {
		octree_alpha *= 0.95;
	}

	color = clamp(mix(octree_color, color, octree_alpha), 0.0, 1.0);
	imageStore(raw_render_layer, pixel_id, color);
}