#version 460

#include "Simulation/Utils.comp"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(rgba8, binding = 0) writeonly uniform image2D pass_1;

struct Texture {
	uint start;
	uint width;
	uint height;
	uint format;
};

layout(std430, binding = 1) buffer TextureBuffer {
	Texture textures[];
};
layout(std430, binding = 2) buffer TextureDataBuffer {
	uint texture_data[];
};

uniform float iTime;
uniform uint  iFrame;
uniform uvec2 iResolution;

vec4 sampleTextureRgba8u(in Texture tex, in vec2 uv) {
	uint x = uint(uv.x * float(tex.width));
	uint y = uint(uv.y * float(tex.height));

	x = uint(mod(x, tex.width - 1));
	y = uint(mod(y, tex.height - 1));

	uint index = tex.start + y * tex.width + x;
	uint color = texture_data[index];

	return vec4(
		float((color >> 24) & 0xFF) / 255.0,
		float((color >> 16) & 0xFF) / 255.0,
		float((color >> 8) & 0xFF) / 255.0,
		float(color & 0xFF) / 255.0
	);
}

vec4 mslp(vec2 uv) {
	float lat = 180.0 * uv.y - 90.0;
	float land = sampleTextureRgba8u(textures[0], uv).x;
	vec4 r;
	if (land >= 1.0) { // land
		r.x = 1012.5 - 6. * cos(lat*PI/45.); // annual mean
		r.y = 15. * sin(lat*PI/90.); // January/July delta
	} else { // ocean
		r.x = 1014.5 - 20. * cos(lat*PI/30.);
		r.y = 20. * sin(lat*PI/35.) * abs(lat)/90.;
	}
	return r;
}

vec4 pass1(vec2 uv) {
	vec4 r = vec4(0);
	for (float i = -20.; i <= 20.; i++) {
		r += mslp(uv + i*E/vec2(iResolution)) * normpdf(i);
	}
	return r;
}

void main() {
	ivec2 pixel_id = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = vec2(pixel_id) / vec2(iResolution);
	uv.y = 1 - uv.y;
	vec4 fragColor;

	fragColor = pass1(uv);
	imageStore(pass_1, pixel_id, fragColor);
}