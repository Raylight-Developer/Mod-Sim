//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
#version 460
#include "Globals.comp"
#include "Inputs.comp"
#include "Texture.comp"
#include "Coloring.comp"
#include "Intersection.comp"
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

Ray f_cameraRay(vec2 uv) {
	return Ray(camera_pos, normalize(camera_p_uv + (camera_p_u * uv.x) + (camera_p_v * uv.y) - camera_pos));
}

void main() {
	ivec2 pixel_id = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (pixel_id - 1 - vec2(resolution) / 2.0) / float(max(resolution.x, resolution.y));

	Ray ray = f_cameraRay(uv);

	vec4 color = vec4(0,0,0,1);
	uint octree_view_depth = 0;
	uint octree_depth = 0;
	float bvh_t_length = MAX_DIST;
	Ray bvh_ray = Ray(ray.origin, 1.0 / ray.direction);

	if (render_particles == 1) {
		float t_length = MAX_DIST;
		float t_dist = MAX_DIST;
		vec2 earth_uv = vec2(0.5);
		if (render_planet == 1) {
			if (f_EarthIntersection(ray, t_dist, earth_uv)) {
				if (t_dist < t_length && t_dist > EPSILON) {
					t_length = t_dist;
					color = sampleTextureRgba8u(textures[render_planet_texture], earth_uv);
				}
			}
		}
		int closest_particle_index = f_visitBvh(ray, octree_depth, t_dist);
		if (closest_particle_index != -1) {
			color = vec4(particleColor(particles[closest_particle_index], t_dist), 1.0);
		}
	}
	else if (render_planet == 1) {
		if (f_rayBvhIntersection(bvh_ray, root_bvh)) {
			float earth_dist = MAX_DIST;
			vec2 earth_uv = vec2(0.5);
			if (f_EarthIntersection(ray, earth_dist, earth_uv)) {
				color = sampleTextureRgba8u(textures[render_planet_texture], earth_uv);
			}
		}
	}
	if (render_octree == 1) {
		for (int i = 0; i < bvh_nodes.length(); i++) {
			Bvh node = bvh_nodes[i];
			node.p_min += 0.1;
			node.p_max -= 0.1;
			if (f_rayBvhIntersection(bvh_ray, node)) {
				octree_view_depth++;
			}
		}
	}
	float octree_alpha = 1.0;
	for (int i = 0; i < octree_view_depth; i++) {
		octree_alpha *= 0.95;
	}

	color = clamp(mix(vec4(1), color, octree_alpha), 0.0, 1.0);
	imageStore(raw_render_layer, pixel_id, color);
}